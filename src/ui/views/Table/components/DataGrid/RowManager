<script lang="ts">
  import { Menu } from "obsidian";
  import { produce } from "immer";
  import { i18n } from "src/lib/stores/i18n";
  import type { GridColDef, GridRowId, GridRowModel } from "./dataGrid";
  import GridCellGroup from "./GridCellGroup.svelte";
  import { Button, Icon } from "obsidian-svelte";

  export let readonly: boolean;
  export let colorModel: (rowId: string) => string | null;

  // Row operation handlers
  export let onRowAdd: () => void;
  export let onRowDelete: (rowId: GridRowId) => void;
  export let onRowEdit: (rowId: GridRowId, row: GridRowModel) => void;
  export let onRowChange: (rowId: GridRowId, row: GridRowModel) => void;

  // Footer row index and columns for add button
  export let footerIndex: number;
  export let sortedColumns: GridColDef[];

  $: t = $i18n.t;

  /**
   * RowManager - handles all row-related operations and menu creation
   * Separates row logic from DataGrid for better maintainability
   */
  export class RowManager {
    /**
     * Creates a context menu for a specific row
     */
    static createRowMenu(
      rowId: GridRowId,
      row: GridRowModel,
      readonly: boolean,
      t: any,
      onRowEdit: (rowId: GridRowId, row: GridRowModel) => void,
      onRowDelete: (rowId: GridRowId) => void
    ): Menu {
      const menu = new Menu();

      // Edit row
      menu.addItem((item) => {
        item
          .setTitle(t("components.data-grid.row.edit"))
          .setIcon("edit")
          .onClick(() => onRowEdit(rowId, row));
      });

      if (!readonly) {
        menu.addSeparator();

        // Delete row
        menu.addItem((item) => {
          item
            .setTitle(t("components.data-grid.row.delete"))
            .setIcon("trash")
            .setWarning(true)
            .onClick(() => onRowDelete(rowId));
        });
      }

      return menu;
    }

    /**
     * Creates a context menu for a specific cell
     */
    static createCellMenu(
      rowId: GridRowId,
      row: GridRowModel,
      column: GridColDef,
      onRowChange: (rowId: GridRowId, row: GridRowModel) => void
    ): Menu {
      const menu = new Menu();

      // Only provide clear option for editable columns
      if (column.editable) {
        menu.addItem((item) => {
          item
            .setTitle("Clear cell")
            .setIcon("x")
            .onClick(() => {
              onRowChange(
                rowId,
                produce(row, (draft) => {
                  draft[column.field] = undefined;
                  return draft;
                })
              );
            });
        });
      }

      return menu;
    }

    /**
     * Gets row styling based on color model and other properties
     */
    static getRowStyle(
      rowId: string,
      colorModel: (rowId: string) => string | null,
      index: number
    ): Record<string, string> {
      const color = colorModel(rowId);
      const style: Record<string, string> = {};

      // Add background color if provided
      if (color) {
        style['--row-background'] = color;
        style['background-color'] = color;
      }

      // Add hover states and other row styling
      style['transition'] = 'background-color 0.2s ease';

      return style;
    }

    /**
     * Validates row data before operations
     */
    static validateRowOperation(
      operation: 'add' | 'delete' | 'edit',
      row?: GridRowModel
    ): { valid: boolean; error?: string } {
      switch (operation) {
        case 'add':
          return { valid: true };
        
        case 'delete':
          return row ? { valid: true } : { valid: false, error: 'Row data required' };
        
        case 'edit':
          return row ? { valid: true } : { valid: false, error: 'Row data required' };
        
        default:
          return { valid: false, error: 'Unknown operation' };
      }
    }

    /**
     * Creates row operation handlers with validation
     */
    static createRowHandlers(
      onRowAdd: () => void,
      onRowDelete: (rowId: GridRowId) => void,
      onRowEdit: (rowId: GridRowId, row: GridRowModel) => void,
      onRowChange: (rowId: GridRowId, row: GridRowModel) => void
    ) {
      return {
        handleRowAdd: () => {
          const validation = RowManager.validateRowOperation('add');
          if (validation.valid) {
            onRowAdd();
          } else {
            console.warn('Row add validation failed:', validation.error);
          }
        },

        handleRowDelete: (rowId: GridRowId) => {
          const validation = RowManager.validateRowOperation('delete');
          if (validation.valid) {
            onRowDelete(rowId);
          } else {
            console.warn('Row delete validation failed:', validation.error);
          }
        },

        handleRowEdit: (rowId: GridRowId, row: GridRowModel) => {
          const validation = RowManager.validateRowOperation('edit', row);
          if (validation.valid) {
            onRowEdit(rowId, row);
          } else {
            console.warn('Row edit validation failed:', validation.error);
          }
        },

        handleRowChange: (rowId: GridRowId, row: GridRowModel) => {
          const validation = RowManager.validateRowOperation('edit', row);
          if (validation.valid) {
            onRowChange(rowId, row);
          } else {
            console.warn('Row change validation failed:', validation.error);
          }
        }
      };
    }
  }
</script>

<div class="row-manager">
  <!-- Row operations will be integrated into GridRow and footer -->
  <!-- This component provides the logic, the UI is handled by parent components -->
</div>

<style>
  .row-manager {
    /* Layout handled by parent DataGrid */
  }
</style>